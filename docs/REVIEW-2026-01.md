# Project Review & Roadmap - Januar 2026

## Executive Summary

**Status:** docgen v0.5.2 ist funktional und erfüllt die Kernaufgabe (PDF-Generierung aus JSON), leidet aber unter:

1. **Technische Schulden:** 0% Test-Coverage, monolithische Struktur, tote Code-Pfade
2. **Komplexität:** 30+ Config-Felder, 5 verschiedene Template-Referenz-Arten, unklare Fehlerbehandlung
3. **Adoption-Barrieren:** Komplexes Setup, unvollständige Features, fehlende Mainstream-Funktionen

**Empfehlung:** Focus auf Simplifikation und Qualität statt neue Features.

---

## 1. KRITISCHE REFACTORING-BEDARFE

### 1.1 Code-Struktur (Priorität: HOCH)

**Problem:** `main.rs` mit 1.384 Zeilen enthält alles:
- CLI-Parsing
- Command-Handler
- Business-Logic
- Template-Detection
- Error-Handling
- Embedded Documentation

**Lösung: Modulaufteilung**

```
cli/src/
├── main.rs (100 lines) - Entry point only
├── cli.rs (150 lines) - Clap structs
├── commands/
│   ├── mod.rs
│   ├── compile.rs (200 lines)
│   ├── build.rs (100 lines)
│   ├── watch.rs (150 lines)
│   ├── client.rs (200 lines)
│   ├── template.rs (150 lines)
│   └── init.rs (100 lines)
├── core/
│   ├── document_types.rs (150 lines) - Detection logic
│   ├── config.rs (100 lines) - company.json validation
│   ├── compiler.rs (150 lines) - Typst invocation
│   └── validator.rs (200 lines) - JSON schema validation
├── error.rs (150 lines) - Custom error types
└── tests/ (NEW)
    ├── integration/
    └── fixtures/
```

**Impact:**
- ✅ Testbar: Jede Funktion isoliert testbar
- ✅ Wartbar: Klare Verantwortlichkeiten
- ✅ Erweiterbar: Neue Commands einfach hinzuzufügen

**Aufwand:** 2-3 Tage Refactoring

---

### 1.2 Testing-Infrastruktur (Priorität: KRITISCH)

**Aktuell:** 8 triviale Unit-Tests, 0 Integration-Tests, 0% Coverage

**Minimum Viable Tests (v0.6.0):**

```rust
// tests/integration/compile_test.rs
#[test]
fn test_compile_invoice_valid_json() {
    let fixture = setup_test_project();
    let result = run_docgen(&["compile", "documents/invoices/2026/test.json"]);
    assert!(result.is_ok());
    assert!(fixture.output("test.pdf").exists());
}

#[test]
fn test_compile_invoice_invalid_json() {
    let result = run_docgen(&["compile", "invalid.json"]);
    assert_eq!(result.error(), DocgenError::InvalidJson);
}

#[test]
fn test_compile_missing_company_json() {
    let fixture = setup_minimal_project(); // No company.json
    let result = run_docgen(&["compile", "invoice.json"]);
    assert_eq!(result.error(), DocgenError::MissingConfig);
}
```

**Test-Kategorien:**
1. **CLI Integration** - Command execution, arguments, output
2. **Document Processing** - Valid/invalid JSON, template detection
3. **Database Operations** - CRUD, numbering, transactions
4. **Template System** - Extraction, forking, auto-update
5. **Error Scenarios** - Missing files, invalid config, compile failures

**Ziel:** 40-60% Coverage für v0.6.0

**Aufwand:** 3-4 Tage für Basis-Tests

---

### 1.3 Toten Code entfernen (Priorität: MITTEL)

**packages.rs (304 Zeilen)** - Komplett durch `local_templates.rs` ersetzt:
```rust
// Diese Funktionen werden NIRGENDWO aufgerufen:
pub fn install_package() { ... }
pub fn remove_package() { ... }
pub fn list_installed_packages() { ... }
pub fn update_all_packages() { ... }
pub fn ensure_packages_installed() { ... }
```

**Aktion:**
```bash
rm cli/src/packages.rs
# Remove from cli/src/lib.rs
# Remove from Cargo.toml if dependencies unused
```

**Impact:** -304 Zeilen, -3 Tests, weniger Verwirrung

**Aufwand:** 1 Stunde

---

## 2. USABILITY-VERBESSERUNGEN

### 2.1 Vereinfachtes Onboarding (Priorität: HOCH)

**Aktuelles Problem:**
```
User muss:
1. docgen installieren
2. docgen init my-business
3. data/company.json editieren (30+ Felder!)
4. docgen template init (?)
5. JSON-Dokument mit 25+ Feldern erstellen
6. docgen compile
7. Output-Ordner finden
```

**Lösung: Interaktiver Init-Wizard**

```bash
docgen init

→ Welcome to docgen! Let's set up your business.

1. Company name: [_________________]
2. Your name: [_________________]
3. Email: [_________________]
4. Language: [Deutsch] English Français ...

→ Optional (press Enter to skip):
5. Address: [_________________]
6. Tax ID: [_________________]
7. Logo file: [_________________]

→ Creating project structure...
✓ data/company.json created
✓ Templates initialized
✓ Example invoice created: documents/invoices/2026/example.json

→ Next steps:
  1. Edit the example invoice: nano documents/invoices/2026/example.json
  2. Compile it: docgen compile documents/invoices/2026/example.json
  3. View PDF: open output/example.pdf
```

**Impact:**
- ✅ Guided experience statt Doku lesen
- ✅ Working example sofort verfügbar
- ✅ Optionale Felder klar markiert

**Aufwand:** 1-2 Tage

---

### 2.2 Config-Validierung (Priorität: HOCH)

**Problem:** Fehlende Felder → Silent Fallback → Verwirrung

**Lösung: JSON Schema + Validierung**

```rust
// core/config.rs
pub struct CompanyConfig {
    // REQUIRED
    pub name: String,
    pub language: String,
    
    // OPTIONAL
    pub address: Option<Address>,
    pub branding: Option<Branding>,
    // ...
}

impl CompanyConfig {
    pub fn validate(&self) -> Result<(), ConfigError> {
        if self.name.is_empty() {
            return Err(ConfigError::MissingField("name"));
        }
        if !VALID_LANGUAGES.contains(&self.language.as_str()) {
            return Err(ConfigError::InvalidLanguage(self.language.clone()));
        }
        if let Some(branding) = &self.branding {
            branding.validate()?; // Check hex colors, font presets
        }
        Ok(())
    }
}
```

**Fehler-Ausgabe:**
```
Error: Invalid configuration in data/company.json

Required field missing: 'name'
Invalid language: 'deutsch' (use 'de' instead)
Invalid color: '#GGG' (must be valid hex color)

See config schema: docgen config --schema
```

**Impact:**
- ✅ Fehler early catch statt runtime
- ✅ Klare Fehlermeldungen
- ✅ Schema als Dokumentation

**Aufwand:** 2 Tage

---

### 2.3 Document-Validierung (Priorität: MITTEL)

**Problem:** Invalid JSON → Typst compile error → Unklare Fehlermeldung

**Lösung: Pre-Compile Validation**

```rust
// core/validator.rs
pub trait DocumentValidator {
    fn validate(&self) -> Result<(), ValidationError>;
}

impl DocumentValidator for InvoiceData {
    fn validate(&self) -> Result<()> {
        // Check required fields
        if self.metadata.document_number.is_empty() {
            return Err(ValidationError::MissingField("document_number"));
        }
        
        // Validate calculations
        let calculated_total = self.calculate_total();
        if (calculated_total - self.total).abs() > 0.01 {
            return Err(ValidationError::CalculationMismatch {
                calculated: calculated_total,
                provided: self.total,
            });
        }
        
        // Check dates
        if self.due_date < self.invoice_date {
            return Err(ValidationError::InvalidDateRange);
        }
        
        Ok(())
    }
}
```

**Fehler-Ausgabe:**
```
Error: Invalid invoice data in RE-2026-001.json

✗ Missing required field: 'document_number'
✗ Calculation mismatch:
    Calculated: 1190.00 EUR
    Provided:   1200.00 EUR
✗ Due date (2026-01-01) is before invoice date (2026-01-15)

Fix these errors and try again.
```

**Impact:**
- ✅ Fehler vor Typst-Kompilierung
- ✅ Klare Fehlerquellen
- ✅ Verhindert falsche Rechnungen

**Aufwand:** 2-3 Tage

---

### 2.4 Bessere Fehler-Meldungen (Priorität: MITTEL)

**Aktuell:** Generic anyhow errors

**Vorher/Nachher:**

| Situation | Aktuell | Besser |
|-----------|---------|--------|
| Typst nicht installiert | `command not found: typst` | `docgen requires Typst to be installed. Install: https://typst.app/` |
| qpdf nicht installiert | `qpdf encryption failed` | `PDF encryption requires qpdf. Install: brew install qpdf` |
| Template nicht gefunden | `file not found: .docgen/templates/invoice/default.typ` | `Templates not initialized. Run: docgen template init` |
| Client nicht gefunden | `Client not found` | `Client K-001 not found. List clients: docgen client list` |
| Datenbank-Fehler | `database error: locked` | `Database is locked (another docgen process running?). Try again.` |

**Implementation:**

```rust
// error.rs
pub enum DocgenError {
    TypstNotInstalled,
    QpdfNotInstalled,
    TemplateNotFound(String),
    ClientNotFound(String),
    DatabaseLocked,
    // ...
}

impl fmt::Display for DocgenError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::TypstNotInstalled => {
                write!(f, "docgen requires Typst to be installed.\n")?;
                write!(f, "Install: https://typst.app/docs/tutorial/installation")
            },
            Self::ClientNotFound(id) => {
                write!(f, "Client {} not found.\n", id)?;
                write!(f, "List clients: docgen client list")
            },
            // ...
        }
    }
}
```

**Aufwand:** 1-2 Tage

---

## 3. AI-WORKFLOW VERBESSERUNGEN

### 3.1 Aktuelles Konzept: "AI erstellt JSON"

**Workflow:**
```
User → "Erstelle Rechnung für Kunde X"
  ↓
AI (Claude) → Generiert invoice.json
  ↓
User → docgen compile invoice.json
  ↓
PDF fertig
```

**Probleme:**
1. **User muss JSON verstehen** - Schema nicht selbsterklärend
2. **Keine Validierung** - AI kann invalide JSON generieren
3. **Keine Iteration** - Fehler erst beim Compile sichtbar
4. **Kein Feedback-Loop** - AI sieht Fehler nicht

---

### 3.2 Verbesserungsvorschläge

#### Option A: Interactive Schema Generation (EINFACH)

**Dokumentation verbessern:**

```markdown
# AI-Workflow Guide

## Für Claude/ChatGPT/etc.

Wenn User eine Rechnung erstellen will:

1. **Frage diese Daten ab:**
   - Client: Name oder Nummer (z.B. "K-001")
   - Leistungen: Was wurde gemacht? (z.B. "40h Webentwicklung")
   - Preis: Stundensatz oder Festpreis?
   - Datum: Rechnungsdatum und Fälligkeitsdatum

2. **Generiere JSON nach diesem Schema:**
   ```json
   {
     "metadata": {
       "document_number": "AUTO",  // "AUTO" = automatisch vergeben
       "client_name": "<Client Name>",
       "invoice_date": "2026-01-26",
       "due_date": "2026-02-09"
     },
     "items": [
       {
         "description": "Webentwicklung",
         "quantity": 40,
         "unit": "Stunden",
         "unit_price": 95.00
       }
     ],
     "subtotal": 3800.00,
     "vat_breakdown": [
       {"rate": 19, "amount": 722.00}
     ],
     "total": 4522.00
   }
   ```

3. **Validierung:**
   - Rechne Subtotal = sum(items)
   - Rechne VAT = subtotal * 19%
   - Rechne Total = subtotal + VAT
   - Prüfe Datum-Plausibilität

4. **Ausgabe:**
   ```
   Ich habe die Rechnung erstellt:
   
   [JSON hier]
   
   Speichere sie als: documents/invoices/2026/RE-2026-001.json
   Kompiliere mit: docgen compile documents/invoices/2026/RE-2026-001.json
   ```
```

**Aufwand:** 1 Tag (Doku erweitern)

---

#### Option B: JSON Schema Bereitstellen (MITTEL)

**JSON Schema für AI-Validierung:**

```json
// schema/invoice.schema.json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "required": ["metadata", "items", "subtotal", "total"],
  "properties": {
    "metadata": {
      "type": "object",
      "required": ["client_name", "invoice_date"],
      "properties": {
        "document_number": {"type": "string"},
        "client_name": {"type": "string", "minLength": 1},
        "invoice_date": {"type": "string", "format": "date"},
        "due_date": {"type": "string", "format": "date"}
      }
    },
    "items": {
      "type": "array",
      "minItems": 1,
      "items": {
        "type": "object",
        "required": ["description", "quantity", "unit_price"],
        "properties": {
          "description": {"type": "string"},
          "quantity": {"type": "number", "minimum": 0},
          "unit": {"type": "string"},
          "unit_price": {"type": "number", "minimum": 0}
        }
      }
    },
    "subtotal": {"type": "number", "minimum": 0},
    "total": {"type": "number", "minimum": 0}
  }
}
```

**AI kann dann validieren BEVOR User es bekommt:**
```
Claude: "Ich validiere die Rechnung gegen Schema... ✓ Alles korrekt!"
```

**Aufwand:** 2 Tage (Schema erstellen, dokumentieren)

---

#### Option C: docgen AI-Mode (KOMPLEX, Optional)

**Interaktiver AI-guided Modus:**

```bash
docgen create invoice --ai

→ I'll help you create an invoice. What information do you have?

User: "Invoice for Acme Corp, 40 hours web development at 95 EUR/h"

→ Got it! Let me confirm:
  - Client: Acme Corp (found in database as K-001)
  - Service: Web development
  - Hours: 40
  - Rate: 95.00 EUR/h
  - Subtotal: 3,800.00 EUR
  - VAT (19%): 722.00 EUR
  - Total: 4,522.00 EUR

Is this correct? [yes/no/edit]: yes

→ Invoice date: [2026-01-26] (press Enter for today)
→ Payment due: [14 days] (press Enter for default)

✓ Invoice RE-2026-001.json created
✓ PDF compiled to output/RE-2026-001.pdf

Open PDF? [y/n]: y
```

**Technisch:**
- Nutzt Claude API (oder lokales LLM)
- Parst User-Input
- Validiert gegen Schema
- Generiert JSON
- Kompiliert direkt

**Aufwand:** 1-2 Wochen (API-Integration, Error-Handling)

---

### 3.3 Empfehlung für AI-Workflow

**Kurzfristig (v0.6.0):**
- ✅ Option A: Verbesserte Dokumentation
- ✅ JSON Schemas in `schema/` Verzeichnis
- ✅ Beispiele für gängige Szenarien

**Mittelfristig (v0.7.0):**
- ⚠️ Option B: Schema-basierte Validierung
- ⚠️ AI-Guide als Markdown (für Claude Project Knowledge)

**Langfristig (v1.0.0+):**
- ❌ Option C: Native AI-Integration (zu komplex für jetzigen Stand)

---

## 4. MAINSTREAM-ADOPTION STRATEGIE

### 4.1 Zielgruppen-Analyse

| Zielgruppe | Bedürfnisse | Aktueller Status | Maßnahmen |
|------------|-------------|------------------|-----------|
| **Freelancer (Solo)** | Einfache Rechnungen, Angebote | ✅ Grundfunktionen OK | Config vereinfachen, Templates |
| **Kleine Agenturen (2-10)** | Mandanten, Projekte, Zeiterfassung | ⚠️ Mandanten OK, Rest fehlt | Zeiterfassung, Multi-User |
| **Steuerberater** | Viele Mandanten, Export, Archivierung | ⚠️ Mandanten OK, Export fehlt | CSV Export, E-Rechnung |
| **Entwickler** | API, Automation, CI/CD | ❌ Kein API, nur CLI | Rust-Crate, Python-Bindings |
| **Non-Tech Users** | GUI, kein Terminal | ❌ Nur CLI | Web-UI (später) |

---

### 4.2 Feature-Priorisierung für Adoption

#### Must-Have (v0.6.0)
1. ✅ **Testing** - Vertrauen durch Qualität
2. ✅ **Config-Validierung** - Fehler early catch
3. ✅ **Bessere Errors** - User verstehen was schief ging
4. ✅ **Dokumentation** - JSON Schemas, Troubleshooting

#### Should-Have (v0.7.0)
5. ⚠️ **Email-Versand** - `docgen send invoice.json --to client@example.com`
6. ⚠️ **Status-Tracking** - `docgen status RE-2026-001` (draft/sent/paid/overdue)
7. ⚠️ **CSV Export** - `docgen export --format csv --year 2026`
8. ⚠️ **Bulk Operations** - `docgen remind --overdue` (Mahnung an überfällige)

#### Nice-to-Have (v0.8.0+)
9. ❌ **Zeiterfassung** - `docgen time start "Meeting Kunde X"`
10. ❌ **Recurring Invoices** - `docgen recurring create --monthly --client K-001`
11. ❌ **Web Dashboard** - `docgen serve` (read-only Übersicht)
12. ❌ **Mobile App** - iOS/Android View-Only App

---

### 4.3 Marketing & Distribution

#### Aktuell
- GitHub Repository
- Homebrew Tap (casoon/tap)
- Manual downloads

#### Verbesserungen

**1. Homebrew Core eintragen** (statt custom tap)
```bash
# Statt:
brew tap casoon/tap
brew install docgen

# Ziel:
brew install docgen  # Direkt aus Homebrew Core
```
**Reichweite:** 10x mehr User entdecken es

**2. Package Manager für andere Plattformen**
- **Linux:** `apt install docgen` (Debian/Ubuntu), `yum install docgen` (RHEL)
- **Windows:** `choco install docgen` oder `scoop install docgen`
- **Rust:** `cargo install docgen` (bereits möglich)

**3. Website & Showcase**
```
https://docgen.io/  (oder .com/.de)
  - Interaktive Demo
  - Template-Galerie
  - Video-Tutorials
  - Erfolgsgeschichten
```

**4. Content Marketing**
- Blog: "Rechnung schreiben ohne Microsoft Word"
- YouTube: "docgen Tutorial für Freelancer"
- Reddit/HN: "Show HN: Open-Source Invoice Generator"
- Dev.to: "Building Business Tools with Typst"

---

## 5. KONKRETE ROADMAP

### v0.6.0 - "Quality & Stability" (3-4 Wochen)

**Focus:** Testing, Refactoring, Usability

**Tasks:**
- [ ] Refactor main.rs in Module (2-3 Tage)
- [ ] Add 40+ Integration Tests (3-4 Tage)
- [ ] Remove packages.rs dead code (1 Stunde)
- [ ] Add config validation (2 Tage)
- [ ] Improve error messages (1-2 Tage)
- [ ] Interactive init wizard (1-2 Tage)
- [ ] JSON schemas in schema/ (2 Tage)
- [ ] Update documentation (1 Tag)

**Release-Kriterien:**
- ✅ 40%+ Test Coverage
- ✅ No dead code
- ✅ Config validation with clear errors
- ✅ Interactive init working
- ✅ All AI guides updated

---

### v0.7.0 - "Power User Features" (4-6 Wochen)

**Focus:** Workflow-Completion

**Tasks:**
- [ ] Email sending integration (3-4 Tage)
- [ ] Document status tracking UI (2-3 Tage)
- [ ] CSV export for accounting (2 Tage)
- [ ] Bulk operations (remind, status update) (2-3 Tage)
- [ ] Complete interactive UI (edit/delete) (2-3 Tage)
- [ ] Performance optimization (1-2 Tage)
- [ ] Package for more platforms (2-3 Tage)

**Release-Kriterien:**
- ✅ Email workflow complete
- ✅ Status tracking end-to-end
- ✅ Export working for tax software
- ✅ Homebrew Core submission
- ✅ 60%+ Test Coverage

---

### v0.8.0 - "Mainstream Ready" (6-8 Wochen)

**Focus:** Non-Technical Users

**Tasks:**
- [ ] Web dashboard (read-only) (1-2 Wochen)
- [ ] Simple time tracking (1 Woche)
- [ ] Recurring invoices (1 Woche)
- [ ] Template marketplace (2 Wochen)
- [ ] Migration tools (from competitors) (1 Woche)
- [ ] Video tutorials (1 Woche)

**Release-Kriterien:**
- ✅ Web UI working
- ✅ Time tracking integrated
- ✅ Recurring invoices automated
- ✅ 10+ community templates
- ✅ 70%+ Test Coverage

---

### v1.0.0 - "Production Grade" (3-6 Monate)

**Focus:** Enterprise Features

**Tasks:**
- [ ] Multi-user support
- [ ] Cloud backup/sync
- [ ] API & SDK (Rust crate, Python bindings)
- [ ] E-Rechnung (ZUGFeRD/XRechnung)
- [ ] Audit logging
- [ ] Advanced reporting
- [ ] Plugin system
- [ ] Mobile app (view-only)

**Release-Kriterien:**
- ✅ Multi-user tested with 10+ users
- ✅ API stable and documented
- ✅ E-Rechnung compliant
- ✅ 80%+ Test Coverage
- ✅ 1000+ active users

---

## 6. ALTERNATIVE STRATEGIEN

### Option A: "Keep it Simple" - Nur Core Features

**Philosophie:** Unix-Tool-Ansatz - eine Sache gut machen

**Scope:**
- ✅ PDF-Generierung (JSON → PDF)
- ✅ 5 Template-Types (Invoice, Offer, Credentials, Concept, Documentation)
- ✅ CLI only
- ❌ No database
- ❌ No interactive UI
- ❌ No email sending
- ❌ No time tracking

**Vorteile:**
- Einfach zu warten
- Testbar
- Kombinierbar mit anderen Tools (z.B. separate Datenbank)

**Nachteile:**
- Weniger Feature-Komplett
- Benötigt mehr Tools im Stack

---

### Option B: "All-in-One" - Business Suite

**Philosophie:** Komplett-Lösung für Freelancer/KMU

**Scope:**
- ✅ PDF-Generierung
- ✅ Client/Project Management
- ✅ Zeiterfassung
- ✅ Expense Tracking
- ✅ Reporting & Analytics
- ✅ Email Integration
- ✅ Cloud Backup
- ✅ Web + Mobile UI

**Vorteile:**
- Ein Tool für alles
- Bessere UX (Integration)
- Höhere Retention

**Nachteile:**
- Sehr komplex
- Lange Entwicklungszeit
- Konkurrenz mit FreshBooks, Lexoffice, etc.

---

### Option C: "Developer Tool" - API-First

**Philosophie:** Rust-Crate für andere Tools

**Scope:**
- ✅ Core als Library (docgen-core)
- ✅ CLI als Referenz-Implementation
- ✅ Python/Node.js Bindings
- ✅ REST API
- ✅ Webhook Support
- ❌ No built-in UI

**Vorteile:**
- Flexibel für Entwickler
- Integration in bestehende Systeme
- Community kann UI bauen

**Nachteile:**
- Nicht für Non-Tech Users
- Kleinere Zielgruppe

---

## 7. EMPFEHLUNG

### Kurzfristig (3 Monate)
**Strategy:** Option A + Selected features from B

1. **Refactor & Test** (v0.6.0)
   - Code-Qualität verbessern
   - Tests einführen
   - Config vereinfachen

2. **Core Features Complete** (v0.7.0)
   - Email sending
   - Status tracking
   - CSV export

3. **Dokumentation & Distribution**
   - AI-Workflow guides
   - Homebrew Core
   - Video tutorials

### Mittelfristig (6-12 Monate)
**Strategy:** Evaluate adoption, then decide

**Wenn 100+ aktive User:**
- → Option B (All-in-One)
- Web UI entwickeln
- Mobile App

**Wenn Entwickler-Community wächst:**
- → Option C (API-First)
- Rust crate publishen
- Bindings für Python/Node

**Wenn Adoption stockt:**
- → Option A (Keep Simple)
- Focus auf Qualität
- Nische (Typst-Users) bedienen

---

## 8. NÄCHSTE SCHRITTE

### Sofort (diese Woche)
1. ✅ Review committed
2. [ ] Entscheidung: Welche Strategy? (A/B/C)
3. [ ] v0.6.0 Milestone in GitHub erstellen
4. [ ] Issues für Refactoring-Tasks anlegen

### Diese Monat
1. [ ] main.rs Refactoring starten
2. [ ] Test-Infrastruktur aufsetzen
3. [ ] Config-Validierung implementieren
4. [ ] JSON Schemas erstellen

### Nächste 3 Monate
1. [ ] v0.6.0 Release
2. [ ] v0.7.0 Features evaluieren
3. [ ] Distribution verbessern (Homebrew Core)
4. [ ] Community-Feedback sammeln

---

## 9. FRAGEN ZUR DISKUSSION

1. **Zielgruppe:** Wer ist Primary User? (Freelancer/Agenturen/Entwickler)
2. **Scope:** Simple Tool oder Business Suite?
3. **Tech-Level:** CLI-Only oder Web-UI notwendig?
4. **AI-Integration:** Dokumentation oder native Claude-API?
5. **Distribution:** Open-Source Community oder kommerzielles Produkt?
6. **Maintenance:** Solo-Projekt oder Team benötigt?
7. **Timeline:** 3 Monate bis v1.0 oder 1 Jahr+?

---

**Erstellt:** 2026-01-26  
**Autor:** Code Review Agent  
**Version:** 1.0  
**Nächstes Review:** Nach v0.6.0 Release
